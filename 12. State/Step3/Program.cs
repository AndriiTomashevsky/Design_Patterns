using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// Назначение паттерна State - Описывает способы построения конечных автоматов

// Реализация игры «1 из 10» 
//Сначала в класс GumballMachine добавляется новое состояние winnerState.
//Реализуется класс WinnerState. 
//Последнее изменение: реализовать призовую игру и добавить переход в состояние WinnerState.Оба изменения вносятся
//в состояние HasQuarterState, так как именно в этом состоянии покупатель дергает за рычаг.

//Зачем создавать отдельное состояние WinnerState? Почему бы не выдать два шарика в состоянии SoldState?
//Состояния SoldState и WinnerState почти полностью идентичны, только WinnerState выдает два шарика вместо одного.Конечно, код выдачи двух 
//шариков можно разместить и в SoldState.Недостаток такого решения заключается в том, что класс начинает представлять сразу ДВА состояния.
//Таким образом, за устранение дублирования приходится платить ясностью кода.Также стоит вспомнить о принципе, представленном в предыдущей 
//главе: «Один класс — одна обязанность». Включая обязанности WinnerState в SoldState, вы наделяете SoldState ДВУМЯ обязанностями.
//А что произойдет, если рекламная акция завершится? Или изменится приз? Таким образом, речь идет о компромиссном решении, принятом 
//на архитектурном уровне. 

//Некоторые аспекты GumballMachine, которые не мешало бы доработать перед выдачей окончательной версии: 

//Состояния SoldState и WinnerState содержат большой объем дублирующегося кода.Как избавиться от дубли- 
//рования? Можно сделать State абстрактным классом и встроить в эти методы некое поведение по умолчанию; 
//в конце концов, сообщения об ошибках не должны быть видны клиенту.Таким образом, обобщенное поведение
//обработки ошибок может наследоваться от абстрактного суперкласса.

//Метод dispense() вызывается всегда, даже если покупатель дернул за рычаг, не бросив монетки.Хотя автомат
//выдает шарик только в правильном состоянии, эта проблема легко решается возвращением логического флага
//из метода turnCrank() или обработкой исключений. Как вы думаете, какое решение лучше?

//Все информация о переходах между состояниями хранится в классах состояний.Какие проблемы могут из-за это- 
//го возникнуть? Не переместить ли эту логику в GumballMachine? Какими достоинствами и недостатками будет обладать такое решение? 

//Если вы планируете создавать большое количество объектов GumballMachine, возможно, экземпляры состоя- 
//ний стоит переместить в статические переменные для совместного использования.Какие изменения придется внести в GumballMachine и классы состояний?

// Посмотреть "Беседа у камина: Состояние и Стратегия" стр. 438

//Паттерн Состояние позволяет объекту иметь много разных вариантов поведения в зависимости от его внутреннего состояния.
//В отличие от процедурных конечных автоматов, состояние в этом паттерне представляется полноценным классом.
//Поведение контекста реализуется делегированием выполняемых операций текущему объекту состояния, с которым он связан посредством композиции. 
//Инкапсуляция состояния в классе локализует его возможные изменения.
//Паттерны Состояние и Стратегия имеют похожие диаграммы классов, но решают разные задачи.
//Паттерн Стратегия обычно определяет в классе контекста поведение алгоритма.
//Паттерн Состояние изменяет поведение контекста в соответствии с изменениями его состояния.
//Переходами между состояниями могут управлять как классы состояний, так и классы контекстов.
//Применение паттерна Состояние обычно увеличивает количество классов в архитектуре. 
//Классы состояний могут совместно использоваться несколькими экземплярами контекстов.

namespace Step3
{
    // Тестовый код почти не изменился, мы только немного сократили его
    class Program
    {
        static void Main(string[] args)
        {
            GumballMachine gumballMachine = new GumballMachine(5);

            Console.WriteLine(gumballMachine);

            gumballMachine.InsertQuarter();
            gumballMachine.TurnCrank();

            Console.WriteLine(gumballMachine);

            gumballMachine.InsertQuarter();
            gumballMachine.TurnCrank();
            gumballMachine.InsertQuarter();
            gumballMachine.TurnCrank();

            gumballMachine.Refill(5);
            gumballMachine.InsertQuarter();
            gumballMachine.TurnCrank();

            Console.WriteLine(gumballMachine);

            Console.ReadKey();
        }
    }
}
